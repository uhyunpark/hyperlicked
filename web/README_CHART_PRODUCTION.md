# Chart Data: Mock vs Production

## Current Implementation (Mock Data)

**File:** `web/components/trading/Chart.tsx`

The chart currently uses **mock data** generated by `generateSampleData()`:
- Creates 100 fake candlesticks going backwards from current time
- Generates random price movements (±2% random walk)
- Timestamps aligned to 1-minute intervals
- **No connection to blockchain trades**

This is fine for development UI work, but in production you need real trade data.

---

## Production Implementation (Real Data)

### How Blockchain Timestamps Work

**Key Concept:** Transactions don't have individual timestamps. All transactions in a block share the **block timestamp**.

```
Block 1234 (timestamp: 2025-10-20 10:09:00.000)
├─ Trade 1: Alice buys 0.5 BTC @ $50,000
├─ Trade 2: Bob sells 1.0 BTC @ $49,999
└─ Trade 3: Carol buys 0.1 BTC @ $50,001

All trades inherit block timestamp: 10:09:00
```

This is how **all blockchains work** (Bitcoin, Ethereum, Cosmos, Hyperliquid, etc.):
- Proposer sets block timestamp when creating block
- All transactions in block use that timestamp
- Blocks typically 100ms apart (HyperLicked) to 12 seconds (Ethereum)

### Data Flow: Blockchain → Chart

```
1. Block Commits (pkg/consensus/engine.go)
   ↓
2. Matching Engine Executes Orders (pkg/app/core/orderbook.go)
   ↓ (generates fills)
3. WebSocket Broadcasts Trades (pkg/api/websocket.go)
   ↓ (sends JSON with timestamp)
4. Frontend Receives Trade (web/lib/useWebSocket.ts)
   ↓ (stores in Zustand)
5. Chart Aggregates into Candlesticks (web/lib/candlestick.ts)
   ↓ (groups by time interval)
6. Chart Updates (web/components/trading/Chart.tsx)
```

### Step-by-Step Integration

#### Step 1: Backend Broadcasts Trades with Timestamps

**Already implemented** in `pkg/api/websocket.go`:

```go
type TradeUpdate struct {
    Type      string  `json:"type"`      // "trade"
    Symbol    string  `json:"symbol"`    // "BTC-USDT"
    Price     int64   `json:"price"`     // USDT cents
    Size      int64   `json:"size"`      // Satoshis
    Side      string  `json:"side"`      // "buy" or "sell"
    Timestamp int64   `json:"timestamp"` // Unix milliseconds (from block.Timestamp)
}
```

**TODO:** Add broadcast call after matching:

```go
// In pkg/app/perp/app.go after order matching
func (a *App) FinalizeBlock(height, timestamp int64, txs [][]byte) Hash {
    // ... matching logic ...

    for _, fill := range fills {
        // Broadcast trade to WebSocket clients
        a.broadcastTrade(fill, timestamp) // Use block timestamp!
    }

    return a.computeStateHash(height, timestamp)
}
```

#### Step 2: Frontend Receives Trades

**Already implemented** in `web/lib/useWebSocket.ts`:

```typescript
ws.onmessage = (event) => {
  const data = JSON.parse(event.data)

  if (data.type === 'trade') {
    useTradingStore.getState().addTrade({
      price: convertPrice(data.price),      // cents → dollars
      size: convertSize(data.size),         // sats → BTC
      side: data.side,
      timestamp: data.timestamp,            // Unix milliseconds from block
    })
  }
}
```

#### Step 3: Aggregate Trades into Candlesticks

**New file:** `web/lib/candlestick.ts` (created above)

```typescript
import { CandlestickAggregator } from '@/lib/candlestick'

const aggregator = new CandlestickAggregator('1m') // 1-minute candles

// Add trades as they arrive
trades.forEach(trade => {
  const updatedCandle = aggregator.addTrade(trade)
  if (updatedCandle) {
    chart.update(updatedCandle) // Update chart with latest candle
  }
})

// Get all candles for initial load
const allCandles = aggregator.getCandles()
candleSeries.setData(allCandles)
```

#### Step 4: Update Chart Component

**Modified:** `web/components/trading/Chart.tsx`

```typescript
import { CandlestickAggregator } from '@/lib/candlestick'

export function Chart() {
  const aggregatorRef = useRef<CandlestickAggregator | null>(null)

  // Initialize aggregator
  useEffect(() => {
    aggregatorRef.current = new CandlestickAggregator(interval)
  }, [interval])

  // Update with real trades
  useEffect(() => {
    if (!aggregatorRef.current || !candleSeriesRef.current || trades.length === 0) return

    const lastTrade = trades[0]
    const updatedCandle = aggregatorRef.current.addTrade(lastTrade)

    if (updatedCandle) {
      candleSeriesRef.current.update(updatedCandle)
    }
  }, [trades])
}
```

---

## Timestamp Sources: Block vs System Time

### ❌ WRONG: Use System Time

```go
// DON'T DO THIS - non-deterministic!
timestamp := time.Now().UnixMilli()
```

**Problem:** Different validators get different times → different state hashes → consensus failure!

### ✅ CORRECT: Use Block Timestamp

```go
// In pkg/consensus/engine.go
func (e *Engine) proposeBlock(view View) *Block {
    payload := e.App.PrepareProposal(e.State.LastCommittedBlock, view)

    block := &Block{
        Height:    e.State.Height + 1,
        View:      view,
        Parent:    e.State.LastCommittedBlock.Hash(),
        Payload:   payload,
        Proposer:  e.ID,
        Timestamp: time.Now().UnixMilli(), // ✅ Proposer sets timestamp ONCE
    }

    return block
}

// All validators use block.Timestamp (deterministic!)
func (a *App) FinalizeBlock(height, timestamp int64, txs [][]byte) Hash {
    // Use timestamp parameter, NOT time.Now()!
    for _, fill := range fills {
        a.broadcastTrade(fill, timestamp) // ✅ Block timestamp
    }
}
```

**Why this works:**
- Proposer creates block with `Timestamp: time.Now()` **once**
- Block gets included in consensus hash
- All validators use **same timestamp** from block
- Deterministic state hash across all nodes

---

## Time Intervals and Aggregation

### Alignment to Intervals

Candlesticks must align to clean time boundaries:

```typescript
// 1-minute candles: align to HH:MM:00
timestamp: 2025-10-20 10:09:37.123
bucket:    2025-10-20 10:09:00.000  // Floor to minute

// 5-minute candles: align to HH:M5:00 (M5 = 0, 5, 10, ...)
timestamp: 2025-10-20 10:09:37.123
bucket:    2025-10-20 10:05:00.000  // Floor to 5-minute interval

// 1-hour candles: align to HH:00:00
timestamp: 2025-10-20 10:09:37.123
bucket:    2025-10-20 10:00:00.000  // Floor to hour
```

**Implementation** (in `web/lib/candlestick.ts`):

```typescript
function getBucketTime(timestamp: number, interval: Interval): number {
  const ms = INTERVAL_MS[interval] // e.g., 60000 for 1m
  return Math.floor(timestamp / ms) * ms
}
```

### Example: Aggregating 5 Trades

```
Trades (all in block at 10:09:30):
1. Buy 0.5 BTC @ $50,000  (timestamp: 1729392570000)
2. Sell 0.2 BTC @ $49,999 (timestamp: 1729392570000)
3. Buy 1.0 BTC @ $50,001  (timestamp: 1729392570000)
4. Sell 0.3 BTC @ $49,998 (timestamp: 1729392570000)
5. Buy 0.1 BTC @ $50,002  (timestamp: 1729392570000)

All trades → same 1-minute bucket (10:09:00):
  Open:  $50,000 (first trade)
  High:  $50,002 (max price)
  Low:   $49,998 (min price)
  Close: $50,002 (last trade)
```

---

## Handling Different Intervals

When user switches intervals (1m → 5m), you need to re-aggregate:

```typescript
function handleIntervalChange(newInterval: Interval) {
  setInterval(newInterval)

  // Option 1: Rebuild from stored trades (best)
  const aggregator = new CandlestickAggregator(newInterval)
  allTrades.forEach(trade => aggregator.addTrade(trade))
  candleSeries.setData(aggregator.getCandles())

  // Option 2: Fetch from backend API (if you add indexer)
  const candles = await fetchHistoricalCandles(symbol, newInterval, from, to)
  candleSeries.setData(candles)
}
```

**Trade Storage:**

You'll need to store trades for re-aggregation:

```typescript
// In web/lib/store.ts
export const useTradingStore = create<TradingState>((set) => ({
  allTrades: [], // Store ALL trades (or last N hours)
  displayTrades: [], // Last 50 for feed display

  addTrade: (trade) => set((state) => ({
    allTrades: [...state.allTrades, trade], // Keep all
    displayTrades: [trade, ...state.displayTrades].slice(0, 50) // Limit display
  }))
}))
```

---

## Performance Considerations

### Problem: Too Many Trades

If you have 1000 trades/second, storing all trades in memory is expensive.

### Solution 1: Keep Only Recent Data

```typescript
// Keep only last 24 hours of trades
const cutoff = Date.now() - 24 * 60 * 60 * 1000
const recentTrades = allTrades.filter(t => t.timestamp > cutoff)
```

### Solution 2: Pre-Aggregated Candles

Instead of storing trades, store finalized candles:

```typescript
// In web/lib/store.ts
export const useTradingStore = create<TradingState>((set) => ({
  candles1m: [], // Finalized 1-minute candles
  candles5m: [], // Finalized 5-minute candles
  activeCandle1m: null, // Current candle (still updating)

  addTrade: (trade) => set((state) => {
    // Update active candle
    const updated = updateCandle(state.activeCandle1m, trade)

    // If candle is complete (new time bucket), finalize it
    if (isCandleComplete(updated, trade)) {
      return {
        candles1m: [...state.candles1m, state.activeCandle1m],
        activeCandle1m: createNewCandle(trade)
      }
    }

    return { activeCandle1m: updated }
  })
}))
```

### Solution 3: Backend Indexer (Phase 3)

Add a separate service that:
- Subscribes to all trades
- Pre-aggregates candles (1m, 5m, 15m, etc.)
- Stores in database (TimescaleDB, InfluxDB)
- Exposes API: `GET /candles?symbol=BTC-USDT&interval=5m&from=1729392000`

**Benefits:**
- Frontend doesn't need to store all trades
- Fast historical queries
- Multiple intervals pre-computed

---

## Migration Path

### Phase 1 (Current): Mock Data ✅
- Use `generateSampleData()` for UI development
- No blockchain dependency
- **Status: Implemented**

### Phase 2 (Next): Real-Time Only
- Integrate `CandlestickAggregator`
- Show candles from live trades only
- No historical data (chart starts empty)
- **Status: Ready to implement** (code provided above)

### Phase 3 (Future): Full History
- Add backend indexer
- Store trade history in database
- API endpoint for historical candles
- **Status: Design phase**

### Phase 4 (Production): Optimized
- Pre-aggregated candles
- Multiple intervals cached
- Fast chart loading (<100ms)
- **Status: Future**

---

## Testing Real Data

To test with real trades:

1. **Start node**: `go run cmd/node/main.go`
2. **Place orders** via frontend
3. **Check WebSocket** in DevTools → Network → WS → Messages
4. **Verify trade broadcasts**:
   ```json
   {
     "type": "trade",
     "symbol": "BTC-USDT",
     "price": 5000000,
     "size": 100000000,
     "side": "buy",
     "timestamp": 1729392570000
   }
   ```
5. **Enable real data mode** in Chart component
6. **Watch chart update** as orders match

---

## Summary: Mock vs Real

| Feature | Mock Data | Real Data |
|---------|-----------|-----------|
| **Timestamp Source** | `Date.now()` in frontend | `block.Timestamp` from blockchain |
| **Data Generation** | Random walk algorithm | Actual trade execution |
| **Historical Data** | 100 fake candles | Only trades since node start |
| **Accuracy** | 0% (fake prices) | 100% (real trades) |
| **Performance** | Instant | Depends on trade volume |
| **Use Case** | UI development | Production |

**Bottom Line:** Mock data is fine for building UI. For production, integrate real trades with block timestamps as shown above.
