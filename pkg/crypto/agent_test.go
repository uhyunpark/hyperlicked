package crypto

import (
	"math/big"
	"testing"
	"time"
)

func TestAgentDelegation(t *testing.T) {
	// User's wallet
	walletSigner, _ := GenerateKey()
	walletAddr := walletSigner.Address()

	// Agent key (generated by frontend, stored in localStorage)
	agentSigner, _ := GenerateKey()
	agentAddr := agentSigner.Address()

	// Create delegation (valid for 7 days)
	expiration := time.Now().Add(7 * 24 * time.Hour)
	delegation := &AgentDelegation{
		Wallet:     walletAddr,
		Agent:      agentAddr,
		Expiration: big.NewInt(expiration.Unix()),
		Nonce:      big.NewInt(1),
	}

	// User signs delegation with wallet
	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	delegationSig, err := agentSignerEIP712.SignDelegation(walletSigner, delegation)
	if err != nil {
		t.Fatalf("failed to sign delegation: %v", err)
	}

	// Verify delegation signature
	valid, err := agentSignerEIP712.VerifyDelegation(delegation, delegationSig)
	if err != nil {
		t.Fatalf("failed to verify delegation: %v", err)
	}

	if !valid {
		t.Error("delegation signature verification failed")
	}
}

func TestAgentOrder(t *testing.T) {
	// Setup: wallet + agent key + delegation
	walletSigner, _ := GenerateKey()
	walletAddr := walletSigner.Address()

	agentSigner, _ := GenerateKey()
	agentAddr := agentSigner.Address()

	expiration := time.Now().Add(7 * 24 * time.Hour)
	delegation := &AgentDelegation{
		Wallet:     walletAddr,
		Agent:      agentAddr,
		Expiration: big.NewInt(expiration.Unix()),
		Nonce:      big.NewInt(1),
	}

	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	delegationSig, _ := agentSignerEIP712.SignDelegation(walletSigner, delegation)

	// Agent signs order (no MetaMask popup!)
	order := &OrderEIP712{
		Symbol:   "BTC-USDT",
		Side:     1,
		Type:     1,
		Price:    big.NewInt(50000),
		Qty:      big.NewInt(100),
		Nonce:    big.NewInt(1),
		Deadline: big.NewInt(0),
		Leverage: 10,
		Owner:    walletAddr, // Wallet address, not agent!
	}

	eip712Signer := NewEIP712Signer(DefaultDomain())
	orderSig, err := eip712Signer.SignOrder(agentSigner, order) // Agent signs
	if err != nil {
		t.Fatalf("failed to sign order: %v", err)
	}

	// Verify agent order
	valid, err := VerifyAgentOrder(order, orderSig, delegation, delegationSig, eip712Signer, agentSignerEIP712)
	if err != nil {
		t.Fatalf("failed to verify agent order: %v", err)
	}

	if !valid {
		t.Error("agent order verification failed")
	}
}

func TestExpiredDelegation(t *testing.T) {
	walletSigner, _ := GenerateKey()
	agentSigner, _ := GenerateKey()

	// Delegation already expired
	expiration := time.Now().Add(-1 * time.Hour) // 1 hour ago
	delegation := &AgentDelegation{
		Wallet:     walletSigner.Address(),
		Agent:      agentSigner.Address(),
		Expiration: big.NewInt(expiration.Unix()),
		Nonce:      big.NewInt(1),
	}

	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	delegationSig, _ := agentSignerEIP712.SignDelegation(walletSigner, delegation)

	// Try to use expired delegation
	order := &OrderEIP712{
		Symbol:   "BTC-USDT",
		Side:     1,
		Type:     1,
		Price:    big.NewInt(50000),
		Qty:      big.NewInt(100),
		Nonce:    big.NewInt(1),
		Deadline: big.NewInt(0),
		Leverage: 10,
		Owner:    walletSigner.Address(),
	}

	eip712Signer := NewEIP712Signer(DefaultDomain())
	orderSig, _ := eip712Signer.SignOrder(agentSigner, order)

	// Should fail - delegation expired
	valid, err := VerifyAgentOrder(order, orderSig, delegation, delegationSig, eip712Signer, agentSignerEIP712)
	if err == nil {
		t.Error("expected error for expired delegation")
	}

	if valid {
		t.Error("expired delegation should not be valid")
	}
}

func TestWrongAgentSignature(t *testing.T) {
	walletSigner, _ := GenerateKey()
	agentSigner, _ := GenerateKey()
	wrongSigner, _ := GenerateKey() // Different agent

	expiration := time.Now().Add(7 * 24 * time.Hour)
	delegation := &AgentDelegation{
		Wallet:     walletSigner.Address(),
		Agent:      agentSigner.Address(), // Authorized agent
		Expiration: big.NewInt(expiration.Unix()),
		Nonce:      big.NewInt(1),
	}

	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	delegationSig, _ := agentSignerEIP712.SignDelegation(walletSigner, delegation)

	// Order signed by WRONG agent
	order := &OrderEIP712{
		Symbol:   "BTC-USDT",
		Side:     1,
		Type:     1,
		Price:    big.NewInt(50000),
		Qty:      big.NewInt(100),
		Nonce:    big.NewInt(1),
		Deadline: big.NewInt(0),
		Leverage: 10,
		Owner:    walletSigner.Address(),
	}

	eip712Signer := NewEIP712Signer(DefaultDomain())
	orderSig, _ := eip712Signer.SignOrder(wrongSigner, order) // Wrong signer!

	// Should fail - wrong agent
	valid, err := VerifyAgentOrder(order, orderSig, delegation, delegationSig, eip712Signer, agentSignerEIP712)
	if err == nil {
		t.Error("expected error for wrong agent signature")
	}

	if valid {
		t.Error("wrong agent signature should not be valid")
	}
}

func TestDelegationJSON(t *testing.T) {
	walletSigner, _ := GenerateKey()
	agentSigner, _ := GenerateKey()

	delegation := &AgentDelegation{
		Wallet:     walletSigner.Address(),
		Agent:      agentSigner.Address(),
		Expiration: big.NewInt(time.Now().Add(7 * 24 * time.Hour).Unix()),
		Nonce:      big.NewInt(1),
	}

	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	json, err := agentSignerEIP712.DelegationToJSON(delegation)
	if err != nil {
		t.Fatalf("failed to generate JSON: %v", err)
	}

	// Should contain required fields
	if len(json) == 0 {
		t.Error("generated empty JSON")
	}

	// Check for key fields (basic smoke test)
	if !contains(json, "AgentDelegation") {
		t.Error("JSON missing AgentDelegation type")
	}
	if !contains(json, "wallet") {
		t.Error("JSON missing wallet field")
	}
	if !contains(json, "agent") {
		t.Error("JSON missing agent field")
	}
}

func contains(s, substr string) bool {
	return len(s) > 0 && len(substr) > 0 && s != "" && substr != "" &&
		(s == substr || (len(s) > len(substr) && findInString(s, substr)))
}

func findInString(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
