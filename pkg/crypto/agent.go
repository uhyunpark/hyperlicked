package crypto

import (
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/signer/core/apitypes"
)

// AgentDelegation represents permission for an agent key to trade on behalf of a wallet
// This is what users sign when they click "Enable Trading"
type AgentDelegation struct {
	Wallet     common.Address // Main wallet address (e.g., MetaMask)
	Agent      common.Address // Temporary agent key address (generated by frontend)
	Expiration *big.Int       // Unix timestamp when delegation expires
	Nonce      *big.Int       // Nonce for replay protection
}

// AgentSigner manages agent key delegations for "Enable Trading" functionality
type AgentSigner struct {
	domain EIP712Domain
}

// NewAgentSigner creates a new agent signer with given domain
func NewAgentSigner(domain EIP712Domain) *AgentSigner {
	return &AgentSigner{domain: domain}
}

// HashDelegation hashes a delegation according to EIP-712 spec
func (a *AgentSigner) HashDelegation(delegation *AgentDelegation) ([]byte, error) {
	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "name", Type: "string"},
				{Name: "version", Type: "string"},
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"AgentDelegation": []apitypes.Type{
				{Name: "wallet", Type: "address"},
				{Name: "agent", Type: "address"},
				{Name: "expiration", Type: "uint256"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		PrimaryType: "AgentDelegation",
		Domain: apitypes.TypedDataDomain{
			Name:              a.domain.Name,
			Version:           a.domain.Version,
			ChainId:           (*math.HexOrDecimal256)(a.domain.ChainID),
			VerifyingContract: a.domain.VerifyingContract.Hex(),
		},
		Message: apitypes.TypedDataMessage{
			"wallet":     delegation.Wallet.Hex(),
			"agent":      delegation.Agent.Hex(),
			"expiration": delegation.Expiration.String(),
			"nonce":      delegation.Nonce.String(),
		},
	}

	domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
	if err != nil {
		return nil, fmt.Errorf("failed to hash domain: %w", err)
	}

	typedDataHash, err := typedData.HashStruct(typedData.PrimaryType, typedData.Message)
	if err != nil {
		return nil, fmt.Errorf("failed to hash message: %w", err)
	}

	rawData := []byte(fmt.Sprintf("\x19\x01%s%s", string(domainSeparator), string(typedDataHash)))
	digest := crypto.Keccak256Hash(rawData)

	return digest.Bytes(), nil
}

// SignDelegation signs a delegation with the wallet's private key
// This is what users sign in MetaMask when clicking "Enable Trading"
func (a *AgentSigner) SignDelegation(walletSigner *Signer, delegation *AgentDelegation) ([]byte, error) {
	hash, err := a.HashDelegation(delegation)
	if err != nil {
		return nil, fmt.Errorf("failed to hash delegation: %w", err)
	}

	signature, err := walletSigner.Sign(hash)
	if err != nil {
		return nil, fmt.Errorf("failed to sign delegation: %w", err)
	}

	return signature, nil
}

// VerifyDelegation verifies that a delegation signature is valid
func (a *AgentSigner) VerifyDelegation(delegation *AgentDelegation, signature []byte) (bool, error) {
	hash, err := a.HashDelegation(delegation)
	if err != nil {
		return false, fmt.Errorf("failed to hash delegation: %w", err)
	}

	recoveredAddr, err := RecoverAddress(hash, signature)
	if err != nil {
		return false, fmt.Errorf("failed to recover address: %w", err)
	}

	return recoveredAddr == delegation.Wallet, nil
}

// DelegationToJSON converts a delegation to JSON for MetaMask signing
func (a *AgentSigner) DelegationToJSON(delegation *AgentDelegation) (string, error) {
	typedData := map[string]interface{}{
		"types": map[string]interface{}{
			"EIP712Domain": []map[string]string{
				{"name": "name", "type": "string"},
				{"name": "version", "type": "string"},
				{"name": "chainId", "type": "uint256"},
				{"name": "verifyingContract", "type": "address"},
			},
			"AgentDelegation": []map[string]string{
				{"name": "wallet", "type": "address"},
				{"name": "agent", "type": "address"},
				{"name": "expiration", "type": "uint256"},
				{"name": "nonce", "type": "uint256"},
			},
		},
		"primaryType": "AgentDelegation",
		"domain": map[string]interface{}{
			"name":              a.domain.Name,
			"version":           a.domain.Version,
			"chainId":           a.domain.ChainID.String(),
			"verifyingContract": a.domain.VerifyingContract.Hex(),
		},
		"message": map[string]interface{}{
			"wallet":     delegation.Wallet.Hex(),
			"agent":      delegation.Agent.Hex(),
			"expiration": delegation.Expiration.String(),
			"nonce":      delegation.Nonce.String(),
		},
	}

	jsonBytes, err := json.MarshalIndent(typedData, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal JSON: %w", err)
	}

	return string(jsonBytes), nil
}

// SignedOrder represents an order signed by an agent key
type SignedOrder struct {
	Order          *OrderEIP712   // The order data
	AgentSignature []byte         // Signature by agent key
	Wallet         common.Address // Original wallet address (for delegation lookup)
}

// VerifyAgentOrder verifies an order signed by an agent key
// Returns true if:
//   1. Agent signature is valid
//   2. Delegation exists and is not expired
//   3. Delegation signature is valid
func VerifyAgentOrder(
	order *OrderEIP712,
	agentSignature []byte,
	delegation *AgentDelegation,
	delegationSignature []byte,
	eip712Signer *EIP712Signer,
	agentSigner *AgentSigner,
) (bool, error) {
	// Step 1: Verify agent signed the order
	orderHash, err := eip712Signer.HashOrder(order)
	if err != nil {
		return false, fmt.Errorf("failed to hash order: %w", err)
	}

	agentAddr, err := RecoverAddress(orderHash, agentSignature)
	if err != nil {
		return false, fmt.Errorf("failed to recover agent address: %w", err)
	}

	if agentAddr != delegation.Agent {
		return false, fmt.Errorf("agent signature mismatch: got %s, want %s", agentAddr.Hex(), delegation.Agent.Hex())
	}

	// Step 2: Verify delegation is not expired
	now := big.NewInt(time.Now().Unix())
	if delegation.Expiration.Cmp(now) < 0 {
		return false, fmt.Errorf("delegation expired at %s", delegation.Expiration.String())
	}

	// Step 3: Verify wallet signed the delegation
	valid, err := agentSigner.VerifyDelegation(delegation, delegationSignature)
	if err != nil {
		return false, fmt.Errorf("failed to verify delegation: %w", err)
	}

	if !valid {
		return false, fmt.Errorf("invalid delegation signature")
	}

	// Step 4: Verify order owner matches delegation wallet
	if order.Owner != delegation.Wallet {
		return false, fmt.Errorf("order owner %s != delegation wallet %s", order.Owner.Hex(), delegation.Wallet.Hex())
	}

	return true, nil
}

// ExampleEnableTrading demonstrates the "Enable Trading" flow
func ExampleEnableTrading() {
	fmt.Println("=== Enable Trading Flow ===")

	// Step 1: User's wallet (MetaMask)
	walletSigner, _ := GenerateKey()
	walletAddr := walletSigner.Address()
	fmt.Printf("1. User's wallet: %s\n", walletAddr.Hex())

	// Step 2: Frontend generates agent key (stored in localStorage)
	agentSigner, _ := GenerateKey()
	agentAddr := agentSigner.Address()
	fmt.Printf("2. Agent key generated: %s\n", agentAddr.Hex())
	fmt.Printf("   (Private key stored in browser localStorage)\n\n")

	// Step 3: Create delegation (expires in 7 days)
	expiration := time.Now().Add(7 * 24 * time.Hour)
	delegation := &AgentDelegation{
		Wallet:     walletAddr,
		Agent:      agentAddr,
		Expiration: big.NewInt(expiration.Unix()),
		Nonce:      big.NewInt(1),
	}

	fmt.Printf("3. User clicks 'Enable Trading'\n")
	fmt.Printf("   Delegation: agent %s can trade until %s\n\n", agentAddr.Hex(), expiration.Format(time.RFC3339))

	// Step 4: User signs delegation with MetaMask
	agentSignerEIP712 := NewAgentSigner(DefaultDomain())
	delegationSig, _ := agentSignerEIP712.SignDelegation(walletSigner, delegation)
	fmt.Printf("4. User signs delegation with MetaMask\n")
	fmt.Printf("   Signature: 0x%x...\n\n", delegationSig[:8])

	// Step 5: Backend stores delegation
	fmt.Println("5. Backend stores delegation")
	fmt.Printf("   Mapping: %s → %s (expires: %s)\n\n", walletAddr.Hex(), agentAddr.Hex(), expiration.Format(time.RFC3339))

	// Step 6: User places order (signed with agent key - NO MetaMask popup!)
	order := &OrderEIP712{
		Symbol:   "BTC-USDT",
		Side:     1,
		Type:     1,
		Price:    big.NewInt(50000),
		Qty:      big.NewInt(100),
		Nonce:    big.NewInt(1),
		Deadline: big.NewInt(0),
		Leverage: 10,
		Owner:    walletAddr, // Still wallet address (agent trades on behalf)
	}

	eip712Signer := NewEIP712Signer(DefaultDomain())
	orderSig, _ := eip712Signer.SignOrder(agentSigner, order) // Agent signs!

	fmt.Println("6. User places order")
	fmt.Printf("   ✓ Signed with agent key (instant, no MetaMask popup!)\n")
	fmt.Printf("   Order signature: 0x%x...\n\n", orderSig[:8])

	// Step 7: Backend verifies order
	fmt.Println("7. Backend verifies order")
	valid, err := VerifyAgentOrder(order, orderSig, delegation, delegationSig, eip712Signer, agentSignerEIP712)
	if err != nil {
		fmt.Printf("   ✗ Verification failed: %v\n", err)
		return
	}

	if valid {
		fmt.Println("   ✓ Agent signature valid")
		fmt.Println("   ✓ Delegation valid and not expired")
		fmt.Println("   ✓ Wallet authorized agent")
		fmt.Println("   ✓ Order accepted!")
	}
}
